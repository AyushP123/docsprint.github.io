<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Range queries &#8212; Getting Started with Xapian v1.4.1</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.4.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Getting Started with Xapian v1.4.1" href="../index.html" />
    <link rel="up" title="How To..." href="index.html" />
    <link rel="next" title="Facets" href="facets.html" />
    <link rel="prev" title="How to filter search results" href="boolean_filters.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="facets.html" title="Facets"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="boolean_filters.html" title="How to filter search results"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Getting Started with Xapian v1.4</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">How To...</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="range-queries">
<h1><a class="toc-backref" href="#id1">Range queries</a><a class="headerlink" href="#range-queries" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#range-queries" id="id1">Range queries</a><ul>
<li><a class="reference internal" href="#i-m-only-interested-in-the-1980s" id="id2">I&#8217;m only interested in the 1980s</a></li>
<li><a class="reference internal" href="#how-xapian-supports-range-queries" id="id3">How Xapian supports range queries</a></li>
<li><a class="reference internal" href="#creating-the-document-values" id="id4">Creating the document values</a></li>
<li><a class="reference internal" href="#searching-with-ranges" id="id5">Searching with ranges</a></li>
<li><a class="reference internal" href="#handling-dates" id="id6">Handling dates</a></li>
<li><a class="reference internal" href="#writing-your-own-rangeprocessor" id="id7">Writing your own RangeProcessor</a></li>
<li><a class="reference internal" href="#performance-limitations" id="id8">Performance limitations</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="i-m-only-interested-in-the-1980s">
<h2><a class="toc-backref" href="#id2">I&#8217;m only interested in the 1980s</a><a class="headerlink" href="#i-m-only-interested-in-the-1980s" title="Permalink to this headline">¶</a></h2>
<p>In the museums dataset we used in our earlier examples, there is a
field <cite>DATE_MADE</cite> that tells us when the object in question was made,
so one of the natural things people might want to do is to only search
for objects made in a particular time period. Suppose we want to
extend our original system to allow that, we&#8217;re going to have to do a
number of things.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Parse the field from the data set to turn it into something consistent;
at the moment it includes years, year ranges (&#8220;1671-1700&#8221;), approximate
years (&#8220;c. 1936&#8221;) and commentary (&#8220;patented 1885&#8221;, or &#8220;1642-1649
(original); 1883 (model)&#8221;). Additionally, some records have no
information about when the object was made.</li>
<li>Store that information in the Xapian database.</li>
<li>Provide a way during search of specifying a date range to constrain to.</li>
</ol>
</div></blockquote>
<p>If we look through the other fields in the data set, there are more
that could be useful for range queries: we could extract the longest
dimension from <cite>MEASUREMENTS</cite> to enable people to restrict to only
very large or very small objects, for instance.</p>
<p>We&#8217;ll see how to perform range searches across both those dimensions,
and then we&#8217;ll look at how to cope with full dates rather than just
years.</p>
</div>
<div class="section" id="how-xapian-supports-range-queries">
<h2><a class="toc-backref" href="#id3">How Xapian supports range queries</a><a class="headerlink" href="#how-xapian-supports-range-queries" title="Permalink to this headline">¶</a></h2>
<p>If you think back to when we introduced the query concepts behind
Xapian, you&#8217;ll remember that one group of query operators is
responsible for handling <em>value ranges</em>: <code class="docutils literal"><span class="pre">OP_VALUE_LE</span></code>,
<code class="docutils literal"><span class="pre">OP_VALUE_GE</span></code> and <code class="docutils literal"><span class="pre">OP_VALUE_RANGE</span></code>.
So we&#8217;ll be tackling range queries by using document values, and constructing
queries using these operators to restrict matches suitably.</p>
<p>Since we want to expose this functionality generally to users, we want
them to be able to type in a query that will include one or more range
restrictions; the QueryParser contains support for doing this, using
<em>range processors</em>, subclasses of <code class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></code>.
Xapian comes with some standard ones itself, or you can write your own.</p>
<p>Since document values are stored as strings in Xapian, and the
operators provided perform string comparisons, we need a way of
converting numbers to strings to store them. For this, Xapian provides
a pair of utility functions: <cite>sortable_serialise</cite> and
<cite>sortable_unserialise</cite>, which convert between floating point numbers
(strictly, each works with a <cite>double</cite>) and a string that will sort in
the same way and so can be compared easily.</p>
</div>
<div class="section" id="creating-the-document-values">
<h2><a class="toc-backref" href="#id4">Creating the document values</a><a class="headerlink" href="#creating-the-document-values" title="Permalink to this headline">¶</a></h2>
<p>We need a new version of our indexer. This one is
<a class="reference external" href="https://github.com/xapian/xapian-docsprint/blob/master/code/c++/index_ranges.cc">index_ranges.cc</a>, and creates document values from both
<cite>MEASUREMENTS</cite> and <cite>DATE_MADE</cite>. We&#8217;ll put the largest dimension in
value slot 0 (fortunately the data is stored in millimetres and
kilograms, so we can cheat a little and assume that dimensions will
always be larger than weights), and a year taken from <cite>DATE_MADE</cite> into
value slot 1 (we choose the first year we can parse, since it can
contain such a variety of date formats).</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>        <span class="c1">// parse the two values we need</span>
	<span class="kt">double</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_number_in_string</span><span class="p">(</span><span class="n">measurements</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
	    <span class="n">doc</span><span class="p">.</span><span class="n">add_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">sortable_serialise</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_number_in_string</span><span class="p">(</span><span class="n">date_made</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">doc</span><span class="p">.</span><span class="n">add_value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">sortable_serialise</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="p">}</span>
</pre></div>
</div>
<p>We run this like so:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/index_ranges.cc code/c++/support.cc -o index_ranges `xapian-config --libs`
$ ./index_ranges data/100-objects-v1.csv db
</pre></div>
</div>
<p>We can check this has created document values using <cite>xapian-delve</cite>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ xapian-delve -V0 db | cat -v
Value 0 for each document: 5:M-@M-@ 8:M-HV 9:M-EM-p 10:M-MF 11:M-AM-0 12:M-AP 15:M-8^P 19:M-Dt 20:M-GM-P 21:M-E 24:M-O: 25:M-BM-@ 26:M-AM-  27:M-BX 29:M-DD 30:M-BM-^P 31:M-6@ 33:M-;` 34:M-A0 35:M-LM-l 36:M-C^P 37:M-9M-p 38:M-A( 39:M-FT 42:M-H2 45:M-N@ 46:M-AP 50:M-:M-^P 51:M-9P 52:M-LM-! 54:M-CM-( 55:M-9M-P 56:M-@P 59:M-D` 61:M-A( 62:M-;@ 64:M-:M-^P 66:M-AM-H 67:M-8` 68:M-@D33333@ 69:M-D^P 70:M-@M-H 71:M-KM-( 72:M-8^P 73:M-5M-^NfffffM-^@ 74:M-5M-^NfffffM-^@ 75:M-C$M-LM-LM-LM-LM-LM-@ 76:M-BM-?33333@ 77:M-C&gt;33333@ 78:M-;M-^@ 79:M-E^T 80:M-9P 81:M-A@ 84:M-9M-t 86:M-L~ 87:M-BM-@ 88:M-9(M-LM-LM-LM-LM-LM-@ 89:M-:M-?33333@ 90:M-8M-C33333@ 91:M-E| 93:M-A( 94:M-@` 97:M-EM-\ 98:M-Bh 100:M-9^P
</pre></div>
</div>
<p>All the odd characters are because <cite>xapian-delve</cite> doesn&#8217;t know to run
<cite>sortable_unserialise</cite> to turn the strings back into numbers.</p>
</div>
<div class="section" id="searching-with-ranges">
<h2><a class="toc-backref" href="#id5">Searching with ranges</a><a class="headerlink" href="#searching-with-ranges" title="Permalink to this headline">¶</a></h2>
<p>All we need to do once we&#8217;ve got the document values in place is to
tell the QueryParser about them. The simplest range processor is
<code class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></code> itself, but here we need two
<code class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></code> instances.</p>
<p>To distinguish between the two different ranges, we&#8217;ll require that
dimensions must be specified with the suffix &#8216;mm&#8217;, but years are just
numbers. For this to work, we have to tell QueryParser about the value
range with a suffix first:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="n">Xapian</span><span class="o">::</span><span class="n">NumberRangeProcessor</span> <span class="n">size_vrp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;mm&quot;</span><span class="p">,</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">RP_SUFFIX</span><span class="p">);</span>
    <span class="n">queryparser</span><span class="p">.</span><span class="n">add_rangeprocessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size_vrp</span><span class="p">);</span>
    <span class="n">Xapian</span><span class="o">::</span><span class="n">NumberRangeProcessor</span> <span class="n">date_vrp</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">queryparser</span><span class="p">.</span><span class="n">add_rangeprocessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">date_vrp</span><span class="p">);</span>
</pre></div>
</div>
<p>The first call has a final parameter of <cite>False</cite> to say that &#8216;mm&#8217; is a
suffix (the default is for it to be a prefix). When using the empty
string, as in the second call, it doesn&#8217;t matter whether you say it&#8217;s
a suffix or prefix, so it&#8217;s convenient to skip that parameter.</p>
<p>This is implemented in <a class="reference external" href="https://github.com/xapian/xapian-docsprint/blob/master/code/c++/search_ranges.cc">search_ranges.cc</a>, which also
modifies the output to show the measurements and date made fields as
well as the title.</p>
<p>We can now restrict across dimensions using queries like &#8216;..50mm&#8217;
(everything at most 50mm in its longest dimension), and across years
using &#8216;1980..1989&#8217;:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges.cc code/c++/support.cc -o search_ranges `xapian-config --libs`
$ ./search_ranges db ..50mm
1: #031 (1588) overall diameter: 50 mm
        Portable universal equinoctial sundial, in brass, signed &quot;A
2: #073 (1701-1721) overall: 15 mm x 44.45 mm, weight: 0.055kg
        Universal pocket sundial
3: #074 (1596) overall: 13 mm x 44.45 mm x 44.45 mm, weight: 0.095kg
        Sundial, made as a locket, gilt metal, part silver
&#39;..50mm&#39;[0:10] = 31 73 74
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges.cc code/c++/support.cc -o search_ranges `xapian-config --libs`
$ ./search_ranges db 1980..1989
1: #050 (1984) overall: 105 mm x 75 mm x 57 mm,
        Quartz Analogue &quot;no battery&quot; wristwatch by Pulsar Quartz (CA
2: #051 (1984) overall: 85 mm x 65 mm x 38 mm,
        Analogue quartz clock with voice controlled alarm by Braun,
&#39;1980..1989&#39;[0:10] = 50 51
</pre></div>
</div>
<p>You can of course combine this with &#8216;normal&#8217; search terms, such as all
clocks made from 1960 onwards:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges.cc code/c++/support.cc -o search_ranges `xapian-config --libs`
$ ./search_ranges db clock 1960..
1: #052 (1974) clock: 1185 x 780 mm, 122 kg; rewind unit: 460 x 640 x 350 mm
        Reconstruction of Dondi&#39;s Astronomical Clock, 1974
2: #051 (1984) overall: 85 mm x 65 mm x 38 mm,
        Analogue quartz clock with voice controlled alarm by Braun,
3: #009 (1973) overall: 380 mm x 300 mm x 192 mm, weight: 6.45kg
        Copy  of a Dwerrihouse skeleton clock with coup-perdu escape
&#39;clock 1960..&#39;[0:10] = 52 51 9
</pre></div>
</div>
<p>and even combining both ranges at once, such as all large objects from the 19th century:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges.cc code/c++/support.cc -o search_ranges `xapian-config --libs`
$ ./search_ranges db 1000..mm 1800..1899
1: #024 (1845-1855) overall: 1850 mm x 350 mm x 250 mm
        Regulator Clock with Gravity Escapement
&#39;1000..mm 1800..1899&#39;[0:10] = 24
</pre></div>
</div>
<p>Note the slightly awkward syntax <em>1000..mm</em>. The suffix must always go
on the end of the entire range; it may also go on the beginning (so
you can do <em>1000mm..mm</em>). Similarly, you can have <em>100mm..200mm</em> or
<em>100..200mm</em> but not <em>100mm..200</em>. These rules are reversed for
prefixes.</p>
<p>If you get the rules wrong, the QueryParser will raise a
<cite>QueryParserError</cite>, which in production code you could catch and
either signal to the user or perhaps try the query again without the
<cite>RangeProcessor</cite> that tripped up.</p>
</div>
<div class="section" id="handling-dates">
<h2><a class="toc-backref" href="#id6">Handling dates</a><a class="headerlink" href="#handling-dates" title="Permalink to this headline">¶</a></h2>
<p>To restrict to a date range, we need to decide how to both store the
date in a document value, and how we want users to input the date
range in their query. <code class="docutils literal"><span class="pre">Xapian::DateRangeProcessor</span></code>, which is part of
Xapian, works by storing the date as a string in the form &#8216;YYYYMMDD&#8217;,
and can take dates in either US style (month/day/year) or European
style (day/month/year).</p>
<p>To show how this works, we&#8217;re going to need to use a different dataset, because
the museums data only gives years the objects were made in; we&#8217;ve built one
using data on the fifty US states, taken from Wikipedia infoboxes on 5th
November 2011 and then tidied up a small amount. The CSV file is
<a class="reference external" href="https://github.com/xapian/xapian-docsprint/blob/master/data/states.csv">states.csv</a>, and the code that did most of the
work is <a class="reference external" href="https://github.com/xapian/xapian-docsprint/blob/master/code/c++/from_wikipedia.cc">from_wikipedia.cc</a>, using a
list of Wikipedia page titles in
<a class="reference external" href="https://github.com/xapian/xapian-docsprint/blob/master/data/us_states_on_wikipedia">us_states_on_wikipedia</a>. The CSV is licensed as
Creative Commons Attribution-Share Alike 3.0, as per Wikipedia.</p>
<p>We need a new indexer for this as well, which is
<a class="reference external" href="https://github.com/xapian/xapian-docsprint/blob/master/code/c++/index_ranges2.cc">index_ranges2.cc</a>. It stores two numbers using
<cite>sortable_serialise</cite>: year of admission in value slot 1 and population
in slot 3. It also stores the date of admission as &#8216;YYYYMMDD&#8217; in
slot 2.  Here&#8217;s the code which does this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>	<span class="c1">// Index each field with a suitable prefix.</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">index_text</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;S&quot;</span><span class="p">);</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">index_text</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;XD&quot;</span><span class="p">);</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">index_text</span><span class="p">(</span><span class="n">motto</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;XM&quot;</span><span class="p">);</span>

	<span class="c1">// Index fields without prefixes for general search.</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">index_text</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">increase_termpos</span><span class="p">();</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">index_text</span><span class="p">(</span><span class="n">description</span><span class="p">);</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">increase_termpos</span><span class="p">();</span>
	<span class="n">termgenerator</span><span class="p">.</span><span class="n">index_text</span><span class="p">(</span><span class="n">motto</span><span class="p">);</span>

	<span class="c1">// Add document values.</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">admitted</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
	    <span class="n">doc</span><span class="p">.</span><span class="n">add_value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">sortable_serialise</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">admitted</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">).</span><span class="n">c_str</span><span class="p">())));</span>
	    <span class="n">doc</span><span class="p">.</span><span class="n">add_value</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">admitted</span><span class="p">);</span> <span class="c1">// YYYYMMDD</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">population</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
	    <span class="n">doc</span><span class="p">.</span><span class="n">add_value</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">sortable_serialise</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">population</span><span class="p">.</span><span class="n">c_str</span><span class="p">())));</span>
	<span class="p">}</span>
</pre></div>
</div>
<p>We&#8217;ll look at just the date ones for now, and come back to the
others in a minute.</p>
<p>We use the indexer in the same way as previous ones:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/index_ranges2.cc code/c++/support.cc -o index_ranges2 `xapian-config --libs`
$ ./index_ranges2 data/states.csv statesdb
</pre></div>
</div>
<p>With this done, we can change the set of value range processors we
give to the QueryParser.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="n">Xapian</span><span class="o">::</span><span class="n">DateRangeProcessor</span> <span class="n">date_vrp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">RP_DATE_PREFER_MDY</span><span class="p">,</span> <span class="mi">1860</span><span class="p">);</span>
    <span class="n">queryparser</span><span class="p">.</span><span class="n">add_rangeprocessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">date_vrp</span><span class="p">);</span>
    <span class="n">Xapian</span><span class="o">::</span><span class="n">NumberRangeProcessor</span> <span class="n">number_vrp</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">queryparser</span><span class="p">.</span><span class="n">add_rangeprocessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_vrp</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Xapian::DateRangeProcessor</span></code> is working on value slot 2, with an
&#8220;epoch&#8221; of 1860 (so two digit years will be considered as starting at
1860 and going forward as far 1959). The second parameter is whether
it should prefer US style dates or not; since we&#8217;re looking at US
states, we&#8217;ve gone for US dates. The <code class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></code>
is as we saw before, which means that it can&#8217;t cope with two digit years.</p>
<p>This enables us to search for any state that talks about the Spanish
in its description:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges2.cc code/c++/support.cc -o search_ranges2 `xapian-config --libs`
$ ./search_ranges2 statesdb spanish
1: #004 State of Montana November 8, 1889
        Population 989,415
2: #019 State of Texas December 29, 1845
        Population 25,145,561
&#39;spanish&#39;[0:10] = 4 19
</pre></div>
</div>
<p>or for all states admitted in the 19th century:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges2.cc code/c++/support.cc -o search_ranges2 `xapian-config --libs`
$ ./search_ranges2 statesdb 1800..1899
1: #001 State of Washington November 11, 1889
        Population 6,744,496
2: #002 State of Arkansas June 15, 1836
        Population 2,915,918
3: #003 State of Oregon February 14, 1859
        Population 3,831,074
4: #004 State of Montana November 8, 1889
        Population 989,415
5: #005 Idaho July 3, 1890
        Population 1,567,582
6: #006 State of Nevada October 31, 1864
        Population 2,700,551
7: #007 State of California September 9, 1850
        Population 37,253,956
8: #009 State of Utah January 4, 1896
        Population 2,763,885
9: #010 State of Wyoming July 10, 1890
        Population 563,626
10: #011 State of Colorado August 1, 1876
        Population 5,029,196
&#39;1800..1899&#39;[0:10] = 1 2 3 4 5 6 7 9 10 11
</pre></div>
</div>
<p>That uses the <code class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></code> on value slot 1, as in
our previous example. Let&#8217;s be more specific and ask for only those
between November 8th 1889, when Montana became part of the Union, and
July 10th 1890, when Wyoming joined:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges2.cc code/c++/support.cc -o search_ranges2 `xapian-config --libs`
$ ./search_ranges2 statesdb 11/08/1889..07/10/1890
1: #001 State of Washington November 11, 1889
        Population 6,744,496
2: #004 State of Montana November 8, 1889
        Population 989,415
3: #005 Idaho July 3, 1890
        Population 1,567,582
4: #010 State of Wyoming July 10, 1890
        Population 563,626
&#39;11/08/1889..07/10/1890&#39;[0:10] = 1 4 5 10
</pre></div>
</div>
<p>That uses the <code class="docutils literal"><span class="pre">Xapian::DateRangeProcessor</span></code> on value slot 2; it can&#8217;t
cope with year ranges, which is why we indexed to both slots 1 and 2.</p>
</div>
<div class="section" id="writing-your-own-rangeprocessor">
<h2><a class="toc-backref" href="#id7">Writing your own RangeProcessor</a><a class="headerlink" href="#writing-your-own-rangeprocessor" title="Permalink to this headline">¶</a></h2>
<p>We haven&#8217;t yet done anything with population. What we want is
something that behaves like <code class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></code>, but knows
what reason possible values are. If we insert it <em>before</em> the
<code class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></code> on slot 1 (year), it can pick up
anything that should be treated as a population, and let everything else be
treated as a year range.</p>
<p>To do this, we need to know how a <code class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></code> gets
called by the QueryParser. What happens is that each processor in turn is
passed the start and end of the range. If it doesn&#8217;t understand the range, it
should return <code class="docutils literal"><span class="pre">Xapian::BAD_VALUENO</span></code>.  If it <em>does</em> understand
the range, it should return the value number to use with
<code class="docutils literal"><span class="pre">Xapian::Query::OP_VALUE_RANGE</span></code> and if it wants to, it can
modify the start and end values (to convert them to the correct format for
the string comparison which <code class="docutils literal"><span class="pre">Xapian::OP_VALUE_RANGE</span></code> uses).</p>
<p>What we&#8217;re going to do is to write a custom <code class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></code>
that accepts numbers in the range 500,000 to 50,000,000; these can&#8217;t
possibly be years in our data set, and encompass the full range of
populations. If either number is outside that range, we will return
<code class="docutils literal"><span class="pre">Xapian::BAD_VALUENO</span></code> and the QueryParser will move on.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="nc">PopulationRangeProcessor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">NumberRangeProcessor</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">check_range_end</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	    <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
	    <span class="kt">char</span> <span class="o">*</span> <span class="n">q</span><span class="p">;</span>
	    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">u</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	    <span class="k">return</span> <span class="o">!</span><span class="n">errno</span> <span class="o">&amp;&amp;</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span> <span class="o">==</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="n">low</span> <span class="o">&amp;&amp;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>

      <span class="k">public</span><span class="o">:</span>
        <span class="n">PopulationRangeProcessor</span><span class="p">(</span><span class="n">Xapian</span><span class="o">::</span><span class="n">valueno</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">low_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high_</span><span class="p">)</span>
	    <span class="o">:</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">NumberRangeProcessor</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span> <span class="n">low</span><span class="p">(</span><span class="n">low_</span><span class="p">),</span> <span class="n">high</span><span class="p">(</span><span class="n">high_</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
	
	<span class="n">Xapian</span><span class="o">::</span><span class="n">Query</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_range_end</span><span class="p">(</span><span class="n">begin</span><span class="p">))</span>
		 <span class="k">return</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">Query</span><span class="p">(</span><span class="n">Xapian</span><span class="o">::</span><span class="n">Query</span><span class="o">::</span><span class="n">OP_INVALID</span><span class="p">);</span>
	    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_range_end</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
		 <span class="k">return</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">Query</span><span class="p">(</span><span class="n">Xapian</span><span class="o">::</span><span class="n">Query</span><span class="o">::</span><span class="n">OP_INVALID</span><span class="p">);</span>
	    <span class="k">return</span> <span class="n">Xapian</span><span class="o">::</span><span class="n">NumberRangeProcessor</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="p">};</span>

    <span class="n">queryparser</span><span class="p">.</span><span class="n">add_rangeprocessor</span><span class="p">(</span>
	<span class="p">(</span><span class="k">new</span> <span class="n">PopulationRangeProcessor</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span> <span class="mi">50000000</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">());</span>
</pre></div>
</div>
<p>Most of the work is in <cite>__call__</cite> (python&#8217;s equivalent of <cite>operator()</cite>
in C++), which gets called with the two strings at either end of the
range in the query string; either but not both can be the empty
string, which indicates an open-ended range.  This method returns a
<code class="docutils literal"><span class="pre">Xapian::Query</span></code> object - if the object doesn&#8217;t want to handle
the range, then this should use operator <code class="docutils literal"><span class="pre">OP_INVALID</span></code>.
it doesn&#8217;t want to handle it; otherwise this query is the range that
is matched - typically using <code class="docutils literal"><span class="pre">OP_VALUE_RANGE</span></code>, but
arbitrary <code class="docutils literal"><span class="pre">Xapian::Query</span></code> objects are supported.</p>
<p>Rather than re-implement <code class="docutils literal"><span class="pre">Xapian::NumberRangeProcessor</span></code>, we wrap it to do
the serialisation (due to the way python interacts with the API it&#8217;s currently
not possible to subclass it successfully here).</p>
<p>Range processors are called in the order they&#8217;re added, so our
custom one gets a chance to look at all ranges, but will only &#8216;claim&#8217;
ranges which use integer numbers within the 500 thousand to 50 million
range.</p>
<p>We can then search for states by population, such as all over 10
million:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges2.cc code/c++/support.cc -o search_ranges2 `xapian-config --libs`
$ ./search_ranges2 statesdb 10000000..
1: #007 State of California September 9, 1850
        Population 37,253,956
2: #019 State of Texas December 29, 1845
        Population 25,145,561
3: #027 State of Illinois December 3, 1818
        Population 12,830,632
4: #030 State of Ohio March 1, 1803
        Population 11,536,504
5: #035 State of Florida March 3, 1845
        Population 18,801,310
6: #040 Commonwealth of Pennsylvania December 12, 1787
        Population 12,702,379
7: #041 State of New York July 26, 1788
        Population 19,378,102
&#39;10000000..&#39;[0:10] = 7 19 27 30 35 40 41
</pre></div>
</div>
<p>Or all that joined the union in the 1780s and have a population now over 10 million:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ g++ `xapian-config --cxxflags` code/c++/search_ranges2.cc code/c++/support.cc -o search_ranges2 `xapian-config --libs`
$ ./search_ranges2 statesdb 1780..1789 10000000..
1: #040 Commonwealth of Pennsylvania December 12, 1787
        Population 12,702,379
2: #041 State of New York July 26, 1788
        Population 19,378,102
&#39;1780..1789 10000000..&#39;[0:10] = 40 41
</pre></div>
</div>
<p>With a little more work, we could support ranges such as &#8216;..5m&#8217; to
mean up to 5 million, or &#8216;..750k&#8217; for up to 750 thousand.</p>
<p>Similarly, it would be possible to use the same approach to create a custom
<code class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></code> that could restrict to a range of years, and
cope with two digit years, as our <code class="docutils literal"><span class="pre">Xapian::DateRangeProcessor</span></code> did for
full dates.</p>
</div>
<div class="section" id="performance-limitations">
<h2><a class="toc-backref" href="#id8">Performance limitations</a><a class="headerlink" href="#performance-limitations" title="Permalink to this headline">¶</a></h2>
<p>Without other terms in a query, a <code class="docutils literal"><span class="pre">Xapian::RangeProcessor</span></code> can cause
a value operation to be performed across the whole database, which means
loading all the values in a given slot. On a small database, this
isn&#8217;t a problem, but for a large one it can have performance
implications: you may end up with very slow queries.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Range queries</a><ul>
<li><a class="reference internal" href="#i-m-only-interested-in-the-1980s">I&#8217;m only interested in the 1980s</a></li>
<li><a class="reference internal" href="#how-xapian-supports-range-queries">How Xapian supports range queries</a></li>
<li><a class="reference internal" href="#creating-the-document-values">Creating the document values</a></li>
<li><a class="reference internal" href="#searching-with-ranges">Searching with ranges</a></li>
<li><a class="reference internal" href="#handling-dates">Handling dates</a></li>
<li><a class="reference internal" href="#writing-your-own-rangeprocessor">Writing your own RangeProcessor</a></li>
<li><a class="reference internal" href="#performance-limitations">Performance limitations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="boolean_filters.html"
                        title="previous chapter">How to filter search results</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="facets.html"
                        title="next chapter">Facets</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/howtos/range_queries.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="facets.html" title="Facets"
             >next</a> |</li>
        <li class="right" >
          <a href="boolean_filters.html" title="How to filter search results"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Getting Started with Xapian v1.4</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >How To...</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2017 Xapian Documentation Team &amp; Contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.9.
    </div>
  </body>
</html>